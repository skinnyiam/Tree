==>> Minimum Depth of Binary Tree :

Code:
    int minDepth(TreeNode* root) {

        queue<pair<TreeNode*,int>> q;
        q.push({root,1});
        while(!q.empty()){
            auto item=q.front();
            TreeNode* node = item.first;
            int depth=item.second;
            q.pop();
            if(node==NULL) continue;
            if(node->left==NULL && node->right==NULL){
                return depth;
            }
            q.push({node->left,depth+1});
                        q.push({node->right,depth+1});

        }
        return 0;
}

Crux:
we iterate through every node level wise and maintain an counter which will increase after every push of the nodes in left and right and if we get node->left null 
node->right null we stop and return to function.

===>>Binary Tree Right Side View

Code :
      vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        if(root==NULL) return ans;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int size=q.size();
            for(int i=0;i<size;i++){
                TreeNode* curr= q.front();
                q.pop();
                if(i==size-1)
                {
                    ans.push_back(curr->val);
                }
                if(curr->left!=NULL) q.push(curr->left);
                if(curr->right!=NULL) q.push(curr->right);
            }
        }
        return ans;
    }
    
  Crux : 
  we iterate through every node level wise and take the size of queue and push only last element of queue this way will get the right view of the tree.
